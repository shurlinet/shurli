package main

import (
	"bufio"
	"context"
	"encoding/hex"
	"flag"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/libp2p/go-libp2p/core/network"
	"github.com/libp2p/go-libp2p/core/peer"
	"github.com/libp2p/go-libp2p/core/peerstore"
	"github.com/libp2p/go-libp2p/core/protocol"

	"github.com/satindergrewal/peer-up/internal/auth"
	"github.com/satindergrewal/peer-up/internal/config"
	"github.com/satindergrewal/peer-up/internal/invite"
	"github.com/satindergrewal/peer-up/pkg/p2pnet"
)

func runJoin(args []string) {
	// Reorder args: move flags before positional args.
	// Go's flag.Parse stops at the first non-flag argument, but users
	// naturally write "peerup join <code> --name laptop". Without reordering,
	// --name and laptop get joined into the invite code, corrupting it.
	args = reorderArgs(args, map[string]bool{"non-interactive": true})

	fs := flag.NewFlagSet("join", flag.ExitOnError)
	configFlag := fs.String("config", "", "path to config file")
	nameFlag := fs.String("name", "", "friendly name for this peer (e.g., \"laptop\")")
	nonInteractive := fs.Bool("non-interactive", false, "machine-friendly output for scripting")
	fs.Parse(args)

	// In non-interactive mode, progress goes to stderr so stdout is clean.
	out := fmt.Printf
	outln := fmt.Println
	if *nonInteractive {
		out = func(format string, a ...any) (int, error) { return fmt.Fprintf(os.Stderr, format, a...) }
		outln = func(a ...any) (int, error) { return fmt.Fprintln(os.Stderr, a...) }
	}

	// Resolve invite code: CLI arg > PEERUP_INVITE_CODE env var > stdin (non-interactive only)
	var code string
	if fs.NArg() >= 1 {
		code = strings.Join(fs.Args(), "")
	} else if env := os.Getenv("PEERUP_INVITE_CODE"); env != "" {
		code = strings.TrimSpace(env)
	} else if *nonInteractive {
		// Read one line from stdin
		scanner := bufio.NewScanner(os.Stdin)
		scanner.Buffer(make([]byte, 4096), 4096)
		if scanner.Scan() {
			code = strings.TrimSpace(scanner.Text())
		}
	}

	if code == "" {
		fmt.Println("Usage: peerup join <invite-code> [--name \"laptop\"] [--non-interactive]")
		fmt.Println()
		fmt.Println("The invite code is generated by 'peerup invite' on the other machine.")
		fmt.Println()
		fmt.Println("In non-interactive mode, the code can also come from:")
		fmt.Println("  PEERUP_INVITE_CODE environment variable")
		fmt.Println("  stdin (one line)")
		osExit(1)
	}

	// Decode invite
	data, err := invite.Decode(code)
	if err != nil {
		fatal("Invalid invite code: %v", err)
	}

	outln("=== peer-up join ===")
	outln()
	out("Relay:   %s\n", data.RelayAddr)
	out("Inviter: %s\n", data.PeerID.String()[:16]+"...")
	outln()

	// Resolve config  - create one if it doesn't exist
	cfgFile, cfg, configDir, created := loadOrCreateConfig(*configFlag, data.RelayAddr)
	if created {
		out("Created new config: %s\n", cfgFile)
	} else {
		out("Using config: %s\n", cfgFile)
	}
	outln()

	// Create P2P network (no connection gating for joining)
	p2pNetwork, err := p2pnet.New(&p2pnet.Config{
		KeyFile:            cfg.Identity.KeyFile,
		Config:             &config.Config{Network: cfg.Network},
		UserAgent:          "peerup/" + version,
		EnableRelay:        true,
		RelayAddrs:         []string{data.RelayAddr},
		ForcePrivate:       cfg.Network.ForcePrivateReachability,
		EnableNATPortMap:   true,
		EnableHolePunching: true,
	})
	if err != nil {
		fatal("P2P network error: %v", err)
	}
	defer p2pNetwork.Close()

	h := p2pNetwork.Host()
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	out("Your Peer ID: %s\n", h.ID())
	outln()

	// Connect to relay
	outln("Connecting to relay...")
	relayInfos, err := p2pnet.ParseRelayAddrs([]string{data.RelayAddr})
	if err != nil {
		fatal("Failed to parse relay address: %v", err)
	}
	for _, ai := range relayInfos {
		if err := h.Connect(ctx, ai); err != nil {
			fatal("Failed to connect to relay: %v", err)
		}
	}
	outln("Connected to relay.")

	// Add relay circuit address for the inviter
	circuitAddr := data.RelayAddr + "/p2p-circuit/p2p/" + data.PeerID.String()
	addrInfo, err := peer.AddrInfoFromString(circuitAddr)
	if err != nil {
		fatal("Failed to parse circuit address: %v", err)
	}
	h.Peerstore().AddAddrs(addrInfo.ID, addrInfo.Addrs, peerstore.PermanentAddrTTL)

	// Open invite protocol stream to inviter (allow relay circuit connections)
	outln("Connecting to inviter...")
	joinCtx := network.WithAllowLimitedConn(ctx, inviteProtocol)
	s, err := h.NewStream(joinCtx, data.PeerID, protocol.ID(inviteProtocol))
	if err != nil {
		fatal("Failed to connect to inviter: %v\n(Is the invite still active?)", err)
	}
	defer s.Close()

	// Send: <token_hex> <our_name>\n
	tokenHex := hex.EncodeToString(data.Token[:])
	joinerName := *nameFlag
	msg := tokenHex
	if joinerName != "" {
		msg += " " + joinerName
	}
	s.Write([]byte(msg + "\n"))

	// Read response (limit to 512 bytes to prevent OOM from malicious inviter)
	scanner := bufio.NewScanner(s)
	scanner.Buffer(make([]byte, 512), 512)
	if !scanner.Scan() {
		err := scanner.Err()
		if err != nil {
			fatal("Failed to read response from inviter: %v", err)
		}
		fatal("No response from inviter (connection closed)")
	}
	response := strings.TrimSpace(scanner.Text())

	if strings.HasPrefix(response, "ERR") {
		fatal("Invite rejected: %s", response)
	}

	if !strings.HasPrefix(response, "OK") {
		fatal("Unexpected response: %s", response)
	}

	// Parse inviter name from "OK <name>"
	inviterName := strings.TrimPrefix(response, "OK")
	inviterName = strings.TrimSpace(inviterName)

	// Add inviter to our authorized_keys
	authKeysPath := cfg.Security.AuthorizedKeysFile
	comment := inviterName
	if comment == "" {
		comment = "invited-" + time.Now().Format("2006-01-02")
	}
	if err := auth.AddPeer(authKeysPath, data.PeerID.String(), comment); err != nil {
		if !strings.Contains(err.Error(), "already authorized") {
			log.Printf("Warning: failed to add peer to authorized_keys: %v", err)
		}
	}

	// Add inviter to names in config (if name was provided)
	if inviterName != "" {
		updateConfigNames(cfgFile, configDir, inviterName, data.PeerID.String())
	}

	outln()
	outln("=== Joined successfully! ===")
	outln()
	if inviterName != "" {
		out("Peer \"%s\" authorized and added to names.\n", inviterName)
	} else {
		out("Peer %s authorized.\n", data.PeerID.String()[:16]+"...")
	}
	out("Config: %s\n", cfgFile)
	out("Authorized keys: %s\n", authKeysPath)
	if !*nonInteractive && inviterName != "" {
		outln()
		outln("Try:")
		out("  peerup ping %s\n", inviterName)
		out("  peerup proxy %s ssh 2222\n", inviterName)
	}
}

// loadOrCreateConfig tries to load an existing config, or creates a minimal one
// using the relay address from the invite code. Returns the config file path,
// loaded config, config directory, and whether a new config was created.
func loadOrCreateConfig(explicitConfig, relayAddr string) (string, *config.NodeConfig, string, bool) {
	// Try loading existing config
	cfgFile, err := config.FindConfigFile(explicitConfig)
	if err == nil {
		cfg, err := config.LoadNodeConfig(cfgFile)
		if err != nil {
			fatal("Config error: %v", err)
		}
		configDir := filepath.Dir(cfgFile)
		config.ResolveConfigPaths(cfg, configDir)
		return cfgFile, cfg, configDir, false
	}

	// No config found  - create one
	fmt.Println("No existing config found. Creating new configuration...")
	fmt.Println()

	configDir, err := config.DefaultConfigDir()
	if err != nil {
		fatal("Failed to determine config directory: %v", err)
	}

	if err := os.MkdirAll(configDir, 0700); err != nil {
		fatal("Failed to create config directory: %v", err)
	}

	// Generate identity
	keyFile := filepath.Join(configDir, "identity.key")
	peerID, err := p2pnet.PeerIDFromKeyFile(keyFile)
	if err != nil {
		fatal("Failed to generate identity: %v", err)
	}
	fmt.Printf("Generated identity: %s\n", peerID)

	// Create authorized_keys
	authKeysFile := filepath.Join(configDir, "authorized_keys")
	if _, err := os.Stat(authKeysFile); os.IsNotExist(err) {
		content := "# authorized_keys - Peer ID allowlist (one per line)\n"
		if err := os.WriteFile(authKeysFile, []byte(content), 0600); err != nil {
			fatal("Failed to create authorized_keys: %v", err)
		}
	}

	// Write config
	cfgFile = filepath.Join(configDir, "config.yaml")
	configContent := nodeConfigTemplate(relayAddr, "peerup join")

	if err := os.WriteFile(cfgFile, []byte(configContent), 0600); err != nil {
		fatal("Failed to write config: %v", err)
	}

	// Load the config we just wrote
	cfg, err := config.LoadNodeConfig(cfgFile)
	if err != nil {
		fatal("Failed to load newly created config: %v", err)
	}
	config.ResolveConfigPaths(cfg, configDir)

	return cfgFile, cfg, configDir, true
}

// sanitizeYAMLName strips characters unsafe for use as a bare YAML key.
// Only allows alphanumeric, hyphen, underscore, and dot.
// Names are capped at 64 characters to prevent abuse from remote peers.
func sanitizeYAMLName(s string) string {
	const maxNameLen = 64
	var b strings.Builder
	b.Grow(len(s))
	for _, r := range s {
		if (r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9') || r == '-' || r == '_' || r == '.' {
			b.WriteRune(r)
			if b.Len() >= maxNameLen {
				break
			}
		}
	}
	return b.String()
}

// updateConfigNames appends a name mapping to the config file.
// This does a simple text append to preserve formatting and comments.
func updateConfigNames(cfgFile, configDir, name, peerIDStr string) {
	// Sanitize name to prevent YAML injection  - the name comes from a remote peer
	name = sanitizeYAMLName(name)
	if name == "" {
		log.Printf("Warning: peer name was empty after sanitization, skipping names update")
		return
	}

	data, err := os.ReadFile(cfgFile)
	if err != nil {
		log.Printf("Warning: could not read config to update names: %v", err)
		return
	}

	content := string(data)

	// Replace "names: {}" with a proper names block
	if strings.Contains(content, "names: {}") {
		replacement := fmt.Sprintf("names:\n  %s: \"%s\"", name, peerIDStr)
		content = strings.Replace(content, "names: {}", replacement, 1)
	} else if strings.Contains(content, "names:") {
		// Append under existing names section  - find the line and add after it
		lines := strings.Split(content, "\n")
		var result []string
		added := false
		for _, line := range lines {
			result = append(result, line)
			if !added && strings.HasPrefix(strings.TrimSpace(line), "names:") && !strings.Contains(line, "{}") {
				result = append(result, fmt.Sprintf("  %s: \"%s\"", name, peerIDStr))
				added = true
			}
		}
		if !added {
			// Fallback: append at end
			result = append(result, fmt.Sprintf("\nnames:\n  %s: \"%s\"", name, peerIDStr))
		}
		content = strings.Join(result, "\n")
	} else {
		// No names section at all
		content += fmt.Sprintf("\nnames:\n  %s: \"%s\"\n", name, peerIDStr)
	}

	if err := os.WriteFile(cfgFile, []byte(content), 0600); err != nil {
		log.Printf("Warning: could not update config names: %v", err)
	}
}
