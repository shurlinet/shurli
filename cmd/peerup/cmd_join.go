package main

import (
	"bufio"
	"context"
	"encoding/hex"
	"flag"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/libp2p/go-libp2p/core/peer"
	"github.com/libp2p/go-libp2p/core/peerstore"
	"github.com/libp2p/go-libp2p/core/protocol"

	"github.com/satindergrewal/peer-up/internal/auth"
	"github.com/satindergrewal/peer-up/internal/config"
	"github.com/satindergrewal/peer-up/internal/invite"
	"github.com/satindergrewal/peer-up/pkg/p2pnet"
)

func runJoin(args []string) {
	fs := flag.NewFlagSet("join", flag.ExitOnError)
	configFlag := fs.String("config", "", "path to config file")
	nameFlag := fs.String("name", "", "friendly name for this peer (e.g., \"laptop\")")
	fs.Parse(args)

	if fs.NArg() < 1 {
		fmt.Println("Usage: peerup join <invite-code> [--name \"laptop\"]")
		fmt.Println()
		fmt.Println("The invite code is generated by 'peerup invite' on the other machine.")
		os.Exit(1)
	}

	// The invite code may span multiple arguments if the user didn't quote it
	code := strings.Join(fs.Args(), "")

	// Decode invite
	data, err := invite.Decode(code)
	if err != nil {
		log.Fatalf("Invalid invite code: %v", err)
	}

	fmt.Println("=== peer-up join ===")
	fmt.Println()
	fmt.Printf("Relay:   %s\n", data.RelayAddr)
	fmt.Printf("Inviter: %s\n", data.PeerID.String()[:16]+"...")
	fmt.Println()

	// Resolve config — create one if it doesn't exist
	cfgFile, cfg, configDir, created := loadOrCreateConfig(*configFlag, data.RelayAddr)
	if created {
		fmt.Printf("Created new config: %s\n", cfgFile)
	} else {
		fmt.Printf("Using config: %s\n", cfgFile)
	}
	fmt.Println()

	// Create P2P network (no connection gating for joining)
	p2pNetwork, err := p2pnet.New(&p2pnet.Config{
		KeyFile:            cfg.Identity.KeyFile,
		Config:             &config.Config{Network: cfg.Network},
		EnableRelay:        true,
		RelayAddrs:         []string{data.RelayAddr},
		ForcePrivate:       cfg.Network.ForcePrivateReachability,
		EnableNATPortMap:   true,
		EnableHolePunching: true,
	})
	if err != nil {
		log.Fatalf("P2P network error: %v", err)
	}
	defer p2pNetwork.Close()

	h := p2pNetwork.Host()
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	fmt.Printf("Your Peer ID: %s\n", h.ID())
	fmt.Println()

	// Connect to relay
	fmt.Println("Connecting to relay...")
	relayInfos, err := p2pnet.ParseRelayAddrs([]string{data.RelayAddr})
	if err != nil {
		log.Fatalf("Failed to parse relay address: %v", err)
	}
	for _, ai := range relayInfos {
		if err := h.Connect(ctx, ai); err != nil {
			log.Fatalf("Failed to connect to relay: %v", err)
		}
	}
	fmt.Println("Connected to relay.")

	// Add relay circuit address for the inviter
	circuitAddr := data.RelayAddr + "/p2p-circuit/p2p/" + data.PeerID.String()
	addrInfo, err := peer.AddrInfoFromString(circuitAddr)
	if err != nil {
		log.Fatalf("Failed to parse circuit address: %v", err)
	}
	h.Peerstore().AddAddrs(addrInfo.ID, addrInfo.Addrs, peerstore.PermanentAddrTTL)

	// Open invite protocol stream to inviter
	fmt.Println("Connecting to inviter...")
	s, err := h.NewStream(ctx, data.PeerID, protocol.ID(inviteProtocol))
	if err != nil {
		log.Fatalf("Failed to connect to inviter: %v\n(Is the invite still active?)", err)
	}
	defer s.Close()

	// Send: <token_hex> <our_name>\n
	tokenHex := hex.EncodeToString(data.Token[:])
	joinerName := *nameFlag
	msg := tokenHex
	if joinerName != "" {
		msg += " " + joinerName
	}
	s.Write([]byte(msg + "\n"))

	// Read response (limit to 512 bytes to prevent OOM from malicious inviter)
	scanner := bufio.NewScanner(s)
	scanner.Buffer(make([]byte, 512), 512)
	if !scanner.Scan() {
		err := scanner.Err()
		if err != nil {
			log.Fatalf("Failed to read response from inviter: %v", err)
		}
		log.Fatalf("No response from inviter (connection closed)")
	}
	response := strings.TrimSpace(scanner.Text())

	if strings.HasPrefix(response, "ERR") {
		log.Fatalf("Invite rejected: %s", response)
	}

	if !strings.HasPrefix(response, "OK") {
		log.Fatalf("Unexpected response: %s", response)
	}

	// Parse inviter name from "OK <name>"
	inviterName := strings.TrimPrefix(response, "OK")
	inviterName = strings.TrimSpace(inviterName)

	// Add inviter to our authorized_keys
	authKeysPath := cfg.Security.AuthorizedKeysFile
	comment := inviterName
	if comment == "" {
		comment = "invited-" + time.Now().Format("2006-01-02")
	}
	if err := auth.AddPeer(authKeysPath, data.PeerID.String(), comment); err != nil {
		if !strings.Contains(err.Error(), "already authorized") {
			log.Printf("Warning: failed to add peer to authorized_keys: %v", err)
		}
	}

	// Add inviter to names in config (if name was provided)
	if inviterName != "" {
		updateConfigNames(cfgFile, configDir, inviterName, data.PeerID.String())
	}

	fmt.Println()
	fmt.Println("=== Joined successfully! ===")
	fmt.Println()
	if inviterName != "" {
		fmt.Printf("Peer \"%s\" authorized and added to names.\n", inviterName)
	} else {
		fmt.Printf("Peer %s authorized.\n", data.PeerID.String()[:16]+"...")
	}
	fmt.Printf("Config: %s\n", cfgFile)
	fmt.Printf("Authorized keys: %s\n", authKeysPath)
	fmt.Println()
	if inviterName != "" {
		fmt.Println("Try:")
		fmt.Printf("  peerup ping %s\n", inviterName)
		fmt.Printf("  peerup proxy %s ssh 2222\n", inviterName)
	}
}

// loadOrCreateConfig tries to load an existing config, or creates a minimal one
// using the relay address from the invite code. Returns the config file path,
// loaded config, config directory, and whether a new config was created.
func loadOrCreateConfig(explicitConfig, relayAddr string) (string, *config.NodeConfig, string, bool) {
	// Try loading existing config
	cfgFile, err := config.FindConfigFile(explicitConfig)
	if err == nil {
		cfg, err := config.LoadNodeConfig(cfgFile)
		if err != nil {
			log.Fatalf("Config error: %v", err)
		}
		configDir := filepath.Dir(cfgFile)
		config.ResolveConfigPaths(cfg, configDir)
		return cfgFile, cfg, configDir, false
	}

	// No config found — create one
	fmt.Println("No existing config found. Creating new configuration...")
	fmt.Println()

	configDir, err := config.DefaultConfigDir()
	if err != nil {
		log.Fatalf("Failed to determine config directory: %v", err)
	}

	if err := os.MkdirAll(configDir, 0700); err != nil {
		log.Fatalf("Failed to create config directory: %v", err)
	}

	// Generate identity
	keyFile := filepath.Join(configDir, "identity.key")
	peerID, err := p2pnet.PeerIDFromKeyFile(keyFile)
	if err != nil {
		log.Fatalf("Failed to generate identity: %v", err)
	}
	fmt.Printf("Generated identity: %s\n", peerID)

	// Create authorized_keys
	authKeysFile := filepath.Join(configDir, "authorized_keys")
	if _, err := os.Stat(authKeysFile); os.IsNotExist(err) {
		content := "# authorized_keys - Peer ID allowlist (one per line)\n"
		if err := os.WriteFile(authKeysFile, []byte(content), 0600); err != nil {
			log.Fatalf("Failed to create authorized_keys: %v", err)
		}
	}

	// Write config
	cfgFile = filepath.Join(configDir, "config.yaml")
	configContent := fmt.Sprintf(`# peer-up configuration
# Generated by: peerup join

identity:
  key_file: "identity.key"

network:
  listen_addresses:
    - "/ip4/0.0.0.0/tcp/0"
    - "/ip4/0.0.0.0/udp/0/quic-v1"
    - "/ip6/::/tcp/0"
    - "/ip6/::/udp/0/quic-v1"
  force_private_reachability: false

relay:
  addresses:
    - "%s"
  reservation_interval: "2m"

discovery:
  rendezvous: "peerup-default-network"
  bootstrap_peers: []

security:
  authorized_keys_file: "authorized_keys"
  enable_connection_gating: true

protocols:
  ping_pong:
    enabled: true
    id: "/pingpong/1.0.0"

names: {}
`, relayAddr)

	if err := os.WriteFile(cfgFile, []byte(configContent), 0600); err != nil {
		log.Fatalf("Failed to write config: %v", err)
	}

	// Load the config we just wrote
	cfg, err := config.LoadNodeConfig(cfgFile)
	if err != nil {
		log.Fatalf("Failed to load newly created config: %v", err)
	}
	config.ResolveConfigPaths(cfg, configDir)

	return cfgFile, cfg, configDir, true
}

// sanitizeYAMLName strips characters unsafe for use as a bare YAML key.
// Only allows alphanumeric, hyphen, underscore, and dot.
func sanitizeYAMLName(s string) string {
	var b strings.Builder
	b.Grow(len(s))
	for _, r := range s {
		if (r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9') || r == '-' || r == '_' || r == '.' {
			b.WriteRune(r)
		}
	}
	return b.String()
}

// updateConfigNames appends a name mapping to the config file.
// This does a simple text append to preserve formatting and comments.
func updateConfigNames(cfgFile, configDir, name, peerIDStr string) {
	// Sanitize name to prevent YAML injection — the name comes from a remote peer
	name = sanitizeYAMLName(name)
	if name == "" {
		log.Printf("Warning: peer name was empty after sanitization, skipping names update")
		return
	}

	data, err := os.ReadFile(cfgFile)
	if err != nil {
		log.Printf("Warning: could not read config to update names: %v", err)
		return
	}

	content := string(data)

	// Replace "names: {}" with a proper names block
	if strings.Contains(content, "names: {}") {
		replacement := fmt.Sprintf("names:\n  %s: \"%s\"", name, peerIDStr)
		content = strings.Replace(content, "names: {}", replacement, 1)
	} else if strings.Contains(content, "names:") {
		// Append under existing names section — find the line and add after it
		lines := strings.Split(content, "\n")
		var result []string
		added := false
		for _, line := range lines {
			result = append(result, line)
			if !added && strings.HasPrefix(strings.TrimSpace(line), "names:") && !strings.Contains(line, "{}") {
				result = append(result, fmt.Sprintf("  %s: \"%s\"", name, peerIDStr))
				added = true
			}
		}
		if !added {
			// Fallback: append at end
			result = append(result, fmt.Sprintf("\nnames:\n  %s: \"%s\"", name, peerIDStr))
		}
		content = strings.Join(result, "\n")
	} else {
		// No names section at all
		content += fmt.Sprintf("\nnames:\n  %s: \"%s\"\n", name, peerIDStr)
	}

	if err := os.WriteFile(cfgFile, []byte(content), 0600); err != nil {
		log.Printf("Warning: could not update config names: %v", err)
	}
}
