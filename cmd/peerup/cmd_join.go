package main

import (
	"bufio"
	"context"
	"flag"

	"fmt"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"

	"github.com/libp2p/go-libp2p/core/network"
	"github.com/libp2p/go-libp2p/core/peer"
	"github.com/libp2p/go-libp2p/core/peerstore"
	"github.com/libp2p/go-libp2p/core/protocol"

	"github.com/satindergrewal/peer-up/internal/auth"
	"github.com/satindergrewal/peer-up/internal/config"
	"github.com/satindergrewal/peer-up/internal/invite"
	"github.com/satindergrewal/peer-up/internal/relay"
	"github.com/satindergrewal/peer-up/pkg/p2pnet"
)

func runJoin(args []string) {
	// Reorder args: move flags before positional args.
	// Go's flag.Parse stops at the first non-flag argument, but users
	// naturally write "peerup join <code> --name laptop". Without reordering,
	// --name and laptop get joined into the invite code, corrupting it.
	args = reorderArgs(args, map[string]bool{"non-interactive": true})

	fs := flag.NewFlagSet("join", flag.ExitOnError)
	configFlag := fs.String("config", "", "path to config file")
	nameFlag := fs.String("name", "", "friendly name for this peer (e.g., \"laptop\")")
	nonInteractive := fs.Bool("non-interactive", false, "machine-friendly output for scripting")
	fs.Parse(args)

	// In non-interactive mode, progress goes to stderr so stdout is clean.
	out := fmt.Printf
	outln := fmt.Println
	if *nonInteractive {
		out = func(format string, a ...any) (int, error) { return fmt.Fprintf(os.Stderr, format, a...) }
		outln = func(a ...any) (int, error) { return fmt.Fprintln(os.Stderr, a...) }
	}

	// Resolve invite code: CLI arg > PEERUP_INVITE_CODE env var > stdin (non-interactive only)
	var code string
	if fs.NArg() >= 1 {
		code = strings.Join(fs.Args(), "")
	} else if env := os.Getenv("PEERUP_INVITE_CODE"); env != "" {
		code = strings.TrimSpace(env)
	} else if *nonInteractive {
		// Read one line from stdin
		scanner := bufio.NewScanner(os.Stdin)
		scanner.Buffer(make([]byte, 4096), 4096)
		if scanner.Scan() {
			code = strings.TrimSpace(scanner.Text())
		}
	}

	if code == "" {
		fmt.Println("Usage: peerup join <invite-code> [--name \"laptop\"] [--non-interactive]")
		fmt.Println()
		fmt.Println("The invite code is generated by 'peerup invite' on the other machine.")
		fmt.Println()
		fmt.Println("In non-interactive mode, the code can also come from:")
		fmt.Println("  PEERUP_INVITE_CODE environment variable")
		fmt.Println("  stdin (one line)")
		osExit(1)
	}

	// Decode invite
	data, err := invite.Decode(code)
	if err != nil {
		fatal("Invalid invite code: %v", err)
	}

	// Dispatch based on version.
	switch data.Version {
	case invite.VersionV2:
		runPairJoin(data, *nameFlag, *configFlag, *nonInteractive, out, outln)
		return
	}

	outln("=== peer-up join ===")
	outln()
	out("Relay:   %s\n", data.RelayAddr)
	out("Inviter: %s\n", data.PeerID.String()[:16]+"...")
	if data.Network != "" {
		out("Network: %s\n", data.Network)
	}
	outln()

	// Resolve config - create one if it doesn't exist.
	// Pass the network namespace from the invite code so the joiner
	// auto-inherits the inviter's private DHT network.
	cfgFile, cfg, configDir, created := loadOrCreateConfig(*configFlag, data.RelayAddr, data.Network)
	if created {
		out("Created new config: %s\n", cfgFile)
	} else {
		out("Using config: %s\n", cfgFile)
	}
	outln()

	// Create P2P network (no connection gating for joining)
	p2pNetwork, err := p2pnet.New(&p2pnet.Config{
		KeyFile:            cfg.Identity.KeyFile,
		Config:             &config.Config{Network: cfg.Network},
		UserAgent:          "peerup/" + version,
		EnableRelay:        true,
		RelayAddrs:         []string{data.RelayAddr},
		ForcePrivate:       cfg.Network.ForcePrivateReachability,
		EnableNATPortMap:   true,
		EnableHolePunching: true,
	})
	if err != nil {
		fatal("P2P network error: %v", err)
	}
	defer p2pNetwork.Close()

	h := p2pNetwork.Host()
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	out("Your Peer ID: %s\n", h.ID())
	outln()

	// Connect to relay
	outln("Connecting to relay...")
	relayInfos, err := p2pnet.ParseRelayAddrs([]string{data.RelayAddr})
	if err != nil {
		fatal("Failed to parse relay address: %v", err)
	}
	for _, ai := range relayInfos {
		if err := h.Connect(ctx, ai); err != nil {
			fatal("Failed to connect to relay: %v", err)
		}
	}
	outln("Connected to relay.")

	// Add relay circuit address for the inviter
	circuitAddr := data.RelayAddr + "/p2p-circuit/p2p/" + data.PeerID.String()
	addrInfo, err := peer.AddrInfoFromString(circuitAddr)
	if err != nil {
		fatal("Failed to parse circuit address: %v", err)
	}
	h.Peerstore().AddAddrs(addrInfo.ID, addrInfo.Addrs, peerstore.PermanentAddrTTL)

	// Open invite protocol stream to inviter (allow relay circuit connections)
	outln("Connecting to inviter...")
	joinCtx := network.WithAllowLimitedConn(ctx, inviteProtocol)
	s, err := h.NewStream(joinCtx, data.PeerID, protocol.ID(inviteProtocol))
	if err != nil {
		fatal("Failed to connect to inviter: %v\n(Is the invite still active?)", err)
	}
	defer s.Close()

	joinerName := *nameFlag
	inviterName := joinPAKE(s, data.Token, joinerName)

	// Add inviter to our authorized_keys
	authKeysPath := cfg.Security.AuthorizedKeysFile
	comment := inviterName
	if comment == "" {
		comment = "invited-" + time.Now().Format("2006-01-02")
	}
	if err := auth.AddPeer(authKeysPath, data.PeerID.String(), comment); err != nil {
		if !strings.Contains(err.Error(), "already authorized") {
			log.Printf("Warning: failed to add peer to authorized_keys: %v", err)
		}
	}

	// Add inviter to names in config (if name was provided)
	if inviterName != "" {
		updateConfigNames(cfgFile, configDir, inviterName, data.PeerID.String())
	}

	outln()
	outln("=== Joined successfully! ===")
	outln()
	if inviterName != "" {
		out("Peer \"%s\" authorized and added to names.\n", inviterName)
	} else {
		out("Peer %s authorized.\n", data.PeerID.String()[:16]+"...")
	}
	out("Config: %s\n", cfgFile)
	out("Authorized keys: %s\n", authKeysPath)
	if !*nonInteractive && inviterName != "" {
		outln()
		outln("Try:")
		out("  peerup ping %s\n", inviterName)
		out("  peerup proxy %s ssh 2222\n", inviterName)
	}
}

// joinPAKE performs the PAKE-secured handshake.
// Returns the inviter's name.
func joinPAKE(s network.Stream, token [8]byte, joinerName string) string {
	// Create PAKE session
	session, err := invite.NewPAKESession()
	if err != nil {
		fatal("PAKE session error: %v", err)
	}

	// Send: [0x01] [32-byte X25519 public key]
	if _, err := s.Write([]byte{invite.VersionV1}); err != nil {
		fatal("Failed to send version byte: %v", err)
	}
	if err := session.WritePublicKey(s); err != nil {
		fatal("Failed to send public key: %v", err)
	}

	// Read inviter's public key (32 bytes)
	inviterPub, err := invite.ReadPublicKey(s)
	if err != nil {
		fatal("Failed to read inviter public key: %v", err)
	}

	// Complete DH exchange with token binding
	if err := session.Complete(inviterPub, token); err != nil {
		fatal("PAKE key exchange failed: %v", err)
	}

	// Send encrypted joiner name
	if err := session.WriteEncrypted(s, []byte(joinerName)); err != nil {
		fatal("Failed to send encrypted name: %v", err)
	}

	// Read encrypted response
	responseBytes, err := session.Decrypt(s)
	if err != nil {
		fatal("Failed to decrypt response (wrong invite code?): %v", err)
	}
	response := string(responseBytes)

	if strings.HasPrefix(response, "ERR") {
		fatal("Invite rejected: %s", response)
	}
	if !strings.HasPrefix(response, "OK") {
		fatal("Unexpected response: %s", response)
	}

	inviterName := strings.TrimPrefix(response, "OK")
	return strings.TrimSpace(inviterName)
}

// runPairJoin handles v2 relay pairing codes.
func runPairJoin(data *invite.InviteData, nameFlag, configFlag string, nonInteractive bool,
	out func(string, ...any) (int, error), outln func(...any) (int, error)) {

	outln("=== peer-up pair-join ===")
	outln()
	out("Relay:   %s\n", data.RelayAddr)
	if data.Network != "" {
		out("Network: %s\n", data.Network)
	}
	outln()

	// Resolve config.
	cfgFile, cfg, configDir, created := loadOrCreateConfig(configFlag, data.RelayAddr, data.Network)
	if created {
		out("Created new config: %s\n", cfgFile)
	} else {
		out("Using config: %s\n", cfgFile)
	}
	outln()

	// Create P2P network (no connection gating for joining).
	p2pNetwork, err := p2pnet.New(&p2pnet.Config{
		KeyFile:            cfg.Identity.KeyFile,
		Config:             &config.Config{Network: cfg.Network},
		UserAgent:          "peerup/" + version,
		EnableRelay:        true,
		RelayAddrs:         []string{data.RelayAddr},
		ForcePrivate:       cfg.Network.ForcePrivateReachability,
		EnableNATPortMap:   true,
		EnableHolePunching: true,
	})
	if err != nil {
		fatal("P2P network error: %v", err)
	}
	defer p2pNetwork.Close()

	h := p2pNetwork.Host()
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	out("Your Peer ID: %s\n", h.ID())
	outln()

	// Connect to relay.
	outln("Connecting to relay...")
	relayInfos, err := p2pnet.ParseRelayAddrs([]string{data.RelayAddr})
	if err != nil {
		fatal("Failed to parse relay address: %v", err)
	}
	for _, ai := range relayInfos {
		if err := h.Connect(ctx, ai); err != nil {
			fatal("Failed to connect to relay: %v", err)
		}
	}
	outln("Connected to relay.")

	// Open pairing protocol stream to relay.
	outln("Sending pairing code...")
	relayPeerID := relayInfos[0].ID
	pairCtx := network.WithAllowLimitedConn(ctx, relay.PairingProtocol)
	s, err := h.NewStream(pairCtx, relayPeerID, protocol.ID(relay.PairingProtocol))
	if err != nil {
		fatal("Failed to open pairing stream: %v", err)
	}
	defer s.Close()

	// Send token + name.
	reqBytes := relay.EncodePairingRequest(data.TokenV2, nameFlag)
	if _, err := s.Write(reqBytes); err != nil {
		fatal("Failed to send pairing request: %v", err)
	}
	// Signal we're done writing so the relay can read.
	s.CloseWrite()

	// Read response.
	status, peers, err := relay.ReadPairingResponse(s)
	if err != nil {
		fatal("Pairing failed: %v", err)
	}
	if status != relay.StatusOK {
		fatal("Pairing failed (status 0x%02x)", status)
	}

	outln()
	outln("=== Paired successfully! ===")
	outln()

	// Add discovered peers to authorized_keys and config names.
	authKeysPath := cfg.Security.AuthorizedKeysFile

	// Load existing names for conflict resolution.
	existingNames := make(map[string]bool)
	if cfg.Names != nil {
		for n := range cfg.Names {
			existingNames[n] = true
		}
	}

	for _, p := range peers {
		peerName := sanitizeYAMLName(p.Name)
		if peerName == "" {
			peerName = "peer-" + p.PeerID.String()[:8]
		}

		// Resolve name conflicts.
		finalName := uniqueName(peerName, existingNames)
		if finalName != peerName {
			out("Name \"%s\" already in use. Registered as \"%s\".\n", peerName, finalName)
			out("  Rename with: peerup config rename %s <newname>\n", finalName)
		}
		existingNames[finalName] = true

		// Authorize peer.
		if err := auth.AddPeer(authKeysPath, p.PeerID.String(), finalName); err != nil {
			if !strings.Contains(err.Error(), "already authorized") {
				log.Printf("Warning: failed to authorize peer: %v", err)
			}
		}

		// Add to config names.
		updateConfigNames(cfgFile, configDir, finalName, p.PeerID.String())

		// Show verification fingerprint.
		emoji, numeric := p2pnet.ComputeFingerprint(h.ID(), p.PeerID)
		out("Peer \"%s\" authorized. [UNVERIFIED]\n", finalName)
		out("  Verification code: %s  (%s)\n", emoji, numeric)
		out("  Verify with: peerup verify %s\n", finalName)
		outln()
	}

	if len(peers) == 0 {
		outln("Authorized on relay. No other peers in this group yet.")
		outln()
	}

	out("Config: %s\n", cfgFile)
	out("Authorized keys: %s\n", authKeysPath)
	outln()

	// Auto-start daemon.
	outln("Starting daemon...")
	daemonCmd := exec.Command(os.Args[0], "daemon")
	daemonCmd.Stdout = os.Stdout
	daemonCmd.Stderr = os.Stderr
	if err := daemonCmd.Start(); err != nil {
		out("Could not auto-start daemon: %v\n", err)
		out("Start manually with: peerup daemon\n")
	} else {
		outln("Daemon started.")
		if !nonInteractive && len(peers) > 0 {
			outln()
			outln("Try:")
			out("  peerup ping %s\n", sanitizeYAMLName(peers[0].Name))
		}
	}
}

// uniqueName appends a numeric suffix if name already exists in the set.
func uniqueName(name string, existing map[string]bool) string {
	if !existing[name] {
		return name
	}
	for i := 2; i <= 100; i++ {
		candidate := fmt.Sprintf("%s-%d", name, i)
		if !existing[candidate] {
			return candidate
		}
	}
	return fmt.Sprintf("%s-%d", name, time.Now().Unix())
}

// loadOrCreateConfig tries to load an existing config, or creates a minimal one
// using the relay address and network namespace from the invite code. Returns
// the config file path, loaded config, config directory, and whether a new
// config was created.
func loadOrCreateConfig(explicitConfig, relayAddr, networkNS string) (string, *config.NodeConfig, string, bool) {
	// Try loading existing config
	cfgFile, err := config.FindConfigFile(explicitConfig)
	if err == nil {
		cfg, err := config.LoadNodeConfig(cfgFile)
		if err != nil {
			fatal("Config error: %v", err)
		}
		configDir := filepath.Dir(cfgFile)
		config.ResolveConfigPaths(cfg, configDir)
		return cfgFile, cfg, configDir, false
	}

	// No config found  - create one
	fmt.Println("No existing config found. Creating new configuration...")
	fmt.Println()

	configDir, err := config.DefaultConfigDir()
	if err != nil {
		fatal("Failed to determine config directory: %v", err)
	}

	if err := os.MkdirAll(configDir, 0700); err != nil {
		fatal("Failed to create config directory: %v", err)
	}

	// Generate identity
	keyFile := filepath.Join(configDir, "identity.key")
	peerID, err := p2pnet.PeerIDFromKeyFile(keyFile)
	if err != nil {
		fatal("Failed to generate identity: %v", err)
	}
	fmt.Printf("Generated identity: %s\n", peerID)

	// Create authorized_keys
	authKeysFile := filepath.Join(configDir, "authorized_keys")
	if _, err := os.Stat(authKeysFile); os.IsNotExist(err) {
		content := "# authorized_keys - Peer ID allowlist (one per line)\n"
		if err := os.WriteFile(authKeysFile, []byte(content), 0600); err != nil {
			fatal("Failed to create authorized_keys: %v", err)
		}
	}

	// Write config
	cfgFile = filepath.Join(configDir, "config.yaml")
	configContent := nodeConfigTemplate(relayAddr, "peerup join", networkNS)

	if err := os.WriteFile(cfgFile, []byte(configContent), 0600); err != nil {
		fatal("Failed to write config: %v", err)
	}

	// Load the config we just wrote
	cfg, err := config.LoadNodeConfig(cfgFile)
	if err != nil {
		fatal("Failed to load newly created config: %v", err)
	}
	config.ResolveConfigPaths(cfg, configDir)

	return cfgFile, cfg, configDir, true
}

// sanitizeYAMLName strips characters unsafe for use as a bare YAML key.
// Only allows alphanumeric, hyphen, underscore, and dot.
// Names are capped at 64 characters to prevent abuse from remote peers.
func sanitizeYAMLName(s string) string {
	const maxNameLen = 64
	var b strings.Builder
	b.Grow(len(s))
	for _, r := range s {
		if (r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9') || r == '-' || r == '_' || r == '.' {
			b.WriteRune(r)
			if b.Len() >= maxNameLen {
				break
			}
		}
	}
	return b.String()
}

// updateConfigNames appends a name mapping to the config file.
// This does a simple text append to preserve formatting and comments.
func updateConfigNames(cfgFile, configDir, name, peerIDStr string) {
	// Sanitize name to prevent YAML injection  - the name comes from a remote peer
	name = sanitizeYAMLName(name)
	if name == "" {
		log.Printf("Warning: peer name was empty after sanitization, skipping names update")
		return
	}

	data, err := os.ReadFile(cfgFile)
	if err != nil {
		log.Printf("Warning: could not read config to update names: %v", err)
		return
	}

	content := string(data)

	// Replace "names: {}" with a proper names block
	if strings.Contains(content, "names: {}") {
		replacement := fmt.Sprintf("names:\n  %s: \"%s\"", name, peerIDStr)
		content = strings.Replace(content, "names: {}", replacement, 1)
	} else if strings.Contains(content, "names:") {
		// Append under existing names section  - find the line and add after it
		lines := strings.Split(content, "\n")
		var result []string
		added := false
		for _, line := range lines {
			result = append(result, line)
			if !added && strings.HasPrefix(strings.TrimSpace(line), "names:") && !strings.Contains(line, "{}") {
				result = append(result, fmt.Sprintf("  %s: \"%s\"", name, peerIDStr))
				added = true
			}
		}
		if !added {
			// Fallback: append at end
			result = append(result, fmt.Sprintf("\nnames:\n  %s: \"%s\"", name, peerIDStr))
		}
		content = strings.Join(result, "\n")
	} else {
		// No names section at all
		content += fmt.Sprintf("\nnames:\n  %s: \"%s\"\n", name, peerIDStr)
	}

	if err := os.WriteFile(cfgFile, []byte(content), 0600); err != nil {
		log.Printf("Warning: could not update config names: %v", err)
	}
}
