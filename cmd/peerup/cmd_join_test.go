package main

import (
	"os"
	"strings"
	"testing"
)

// ----- nodeConfigTemplate tests -----

func TestNodeConfigTemplate(t *testing.T) {
	relayAddr := "/ip4/1.2.3.4/tcp/7777/p2p/12D3KooWTest"
	generator := "peerup init"

	output := nodeConfigTemplate(relayAddr, generator)

	checks := []struct {
		name string
		want string
	}{
		{"has version", "version: 1"},
		{"has identity key_file", `key_file: "identity.key"`},
		{"has relay address", relayAddr},
		{"has generator comment", "Generated by: peerup init"},
		{"has rendezvous", `rendezvous: "peerup-default-network"`},
		{"has authorized_keys_file", `authorized_keys_file: "authorized_keys"`},
		{"has connection gating enabled", "enable_connection_gating: true"},
		{"has ping_pong enabled", "enabled: true"},
		{"has ping_pong protocol", `id: "/pingpong/1.0.0"`},
		{"has names section", "names: {}"},
		{"has IPv4 TCP listen", "/ip4/0.0.0.0/tcp/0"},
		{"has IPv4 QUIC listen", "/ip4/0.0.0.0/udp/0/quic-v1"},
		{"has IPv6 TCP listen", "/ip6/::/tcp/0"},
		{"has IPv6 QUIC listen", "/ip6/::/udp/0/quic-v1"},
	}

	for _, c := range checks {
		t.Run(c.name, func(t *testing.T) {
			if !strings.Contains(output, c.want) {
				t.Errorf("template should contain %q", c.want)
			}
		})
	}
}

func TestNodeConfigTemplateDifferentInputs(t *testing.T) {
	t.Run("different relay addr", func(t *testing.T) {
		out := nodeConfigTemplate("/ip6/::1/tcp/9999/p2p/12D3KooWXYZ", "peerup join")
		if !strings.Contains(out, "/ip6/::1/tcp/9999/p2p/12D3KooWXYZ") {
			t.Error("template should contain the provided relay address")
		}
		if !strings.Contains(out, "Generated by: peerup join") {
			t.Error("template should contain the generator name")
		}
	})

	t.Run("empty relay uses empty string", func(t *testing.T) {
		out := nodeConfigTemplate("", "test")
		if !strings.Contains(out, `- ""`) {
			t.Error("template should contain empty relay address in list")
		}
	})
}

// ----- updateConfigNames tests -----

func TestUpdateConfigNames(t *testing.T) {
	t.Run("replace empty names section", func(t *testing.T) {
		dir := t.TempDir()
		cfgFile := dir + "/config.yaml"
		os.WriteFile(cfgFile, []byte("version: 1\nnames: {}\n"), 0600)

		updateConfigNames(cfgFile, dir, "laptop", "12D3KooWTestPeerID")

		data, _ := os.ReadFile(cfgFile)
		got := string(data)
		if !strings.Contains(got, `laptop: "12D3KooWTestPeerID"`) {
			t.Errorf("should contain name mapping, got:\n%s", got)
		}
		if strings.Contains(got, "names: {}") {
			t.Error("should have replaced empty names section")
		}
	})

	t.Run("append to existing names section", func(t *testing.T) {
		dir := t.TempDir()
		cfgFile := dir + "/config.yaml"
		os.WriteFile(cfgFile, []byte("version: 1\nnames:\n  existing: \"12D3KooWExisting\"\n"), 0600)

		updateConfigNames(cfgFile, dir, "newpeer", "12D3KooWNewPeer")

		data, _ := os.ReadFile(cfgFile)
		got := string(data)
		if !strings.Contains(got, `existing: "12D3KooWExisting"`) {
			t.Error("should preserve existing name")
		}
		if !strings.Contains(got, `newpeer: "12D3KooWNewPeer"`) {
			t.Error("should contain new name")
		}
	})

	t.Run("add names section when missing", func(t *testing.T) {
		dir := t.TempDir()
		cfgFile := dir + "/config.yaml"
		os.WriteFile(cfgFile, []byte("version: 1\n"), 0600)

		updateConfigNames(cfgFile, dir, "desktop", "12D3KooWDesktop")

		data, _ := os.ReadFile(cfgFile)
		got := string(data)
		if !strings.Contains(got, "names:") {
			t.Error("should have added names section")
		}
		if !strings.Contains(got, `desktop: "12D3KooWDesktop"`) {
			t.Error("should contain name mapping")
		}
	})

	t.Run("sanitized empty name is skipped", func(t *testing.T) {
		dir := t.TempDir()
		cfgFile := dir + "/config.yaml"
		os.WriteFile(cfgFile, []byte("version: 1\nnames: {}\n"), 0600)

		updateConfigNames(cfgFile, dir, "!@#$%", "12D3KooWBadName")

		data, _ := os.ReadFile(cfgFile)
		got := string(data)
		// Name is all special chars → sanitized to empty → skip update
		if !strings.Contains(got, "names: {}") {
			t.Errorf("should not have modified names, got:\n%s", got)
		}
	})

	t.Run("yaml injection stripped", func(t *testing.T) {
		dir := t.TempDir()
		cfgFile := dir + "/config.yaml"
		os.WriteFile(cfgFile, []byte("version: 1\nnames: {}\n"), 0600)

		// Attempt injection: "evil: {inject: true}" sanitizes to "evilinjecttrue"
		updateConfigNames(cfgFile, dir, "evil: {inject: true}", "12D3KooWEvil")

		data, _ := os.ReadFile(cfgFile)
		got := string(data)
		// The key "evil:" with colon should NOT appear  - sanitized to "evilinjecttrue"
		if strings.Contains(got, "evil:") && strings.Contains(got, "inject:") {
			t.Errorf("YAML injection should be sanitized, got:\n%s", got)
		}
		if !strings.Contains(got, `evilinjecttrue: "12D3KooWEvil"`) {
			t.Errorf("sanitized name should be 'evilinjecttrue', got:\n%s", got)
		}
	})

	t.Run("missing config file is handled gracefully", func(t *testing.T) {
		dir := t.TempDir()
		cfgFile := dir + "/nonexistent.yaml"

		// Should not panic  - just log a warning
		updateConfigNames(cfgFile, dir, "test", "12D3KooWTest")
	})
}
