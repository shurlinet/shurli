package main

import (
	"bufio"
	"context"
	"crypto/hmac"
	"crypto/sha256"
	"encoding/hex"
	"flag"

	"fmt"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"

	"github.com/libp2p/go-libp2p/core/network"
	"github.com/libp2p/go-libp2p/core/peer"
	"github.com/libp2p/go-libp2p/core/peerstore"
	"github.com/libp2p/go-libp2p/core/protocol"

	"github.com/shurlinet/shurli/internal/auth"
	"github.com/shurlinet/shurli/internal/config"
	"github.com/shurlinet/shurli/internal/invite"
	"github.com/shurlinet/shurli/internal/relay"
	"github.com/shurlinet/shurli/pkg/p2pnet"
)

func runJoin(args []string) {
	// Reorder args: move flags before positional args.
	// Go's flag.Parse stops at the first non-flag argument, but users
	// naturally write "shurli join <code> --name laptop". Without reordering,
	// --name and laptop get joined into the invite code, corrupting it.
	args = reorderArgs(args, map[string]bool{"non-interactive": true})

	fs := flag.NewFlagSet("join", flag.ExitOnError)
	configFlag := fs.String("config", "", "path to config file")
	nameFlag := fs.String("name", "", "friendly name for this peer (e.g., \"laptop\")")
	nonInteractive := fs.Bool("non-interactive", false, "machine-friendly output for scripting")
	fs.Parse(args)

	// In non-interactive mode, progress goes to stderr so stdout is clean.
	out := fmt.Printf
	outln := fmt.Println
	if *nonInteractive {
		out = func(format string, a ...any) (int, error) { return fmt.Fprintf(os.Stderr, format, a...) }
		outln = func(a ...any) (int, error) { return fmt.Fprintln(os.Stderr, a...) }
	}

	// Resolve invite code: CLI arg > SHURLI_INVITE_CODE env var > stdin (non-interactive only)
	var code string
	if fs.NArg() >= 1 {
		code = strings.Join(fs.Args(), "")
	} else if env := os.Getenv("SHURLI_INVITE_CODE"); env != "" {
		code = strings.TrimSpace(env)
	} else if *nonInteractive {
		// Read one line from stdin
		scanner := bufio.NewScanner(os.Stdin)
		scanner.Buffer(make([]byte, 4096), 4096)
		if scanner.Scan() {
			code = strings.TrimSpace(scanner.Text())
		}
	}

	if code == "" {
		fmt.Println("Usage: shurli join <invite-code> [--name \"laptop\"] [--non-interactive]")
		fmt.Println()
		fmt.Println("The invite code is generated by 'shurli invite' on the other machine.")
		fmt.Println()
		fmt.Println("In non-interactive mode, the code can also come from:")
		fmt.Println("  SHURLI_INVITE_CODE environment variable")
		fmt.Println("  stdin (one line)")
		osExit(1)
	}

	// Decode invite
	data, err := invite.Decode(code)
	if err != nil {
		fatal("Invalid invite code: %v", err)
	}

	// Dispatch based on version.
	switch data.Version {
	case invite.VersionV2:
		runPairJoin(data, *nameFlag, *configFlag, *nonInteractive, out, outln)
		return
	}

	outln("=== Shurli join ===")
	outln()
	out("Relay:   %s\n", data.RelayAddr)
	out("Inviter: %s\n", data.PeerID.String()[:16]+"...")
	if data.Network != "" {
		out("Network: %s\n", data.Network)
	}
	outln()

	// Resolve config - create one if it doesn't exist.
	// Pass the network namespace from the invite code so the joiner
	// auto-inherits the inviter's private DHT network.
	cfgFile, cfg, configDir, created := loadOrCreateConfig(*configFlag, data.RelayAddr, data.Network)
	if created {
		out("Created new config: %s\n", cfgFile)
	} else {
		out("Using config: %s\n", cfgFile)
	}
	outln()

	// Create P2P network (no connection gating for joining)
	p2pNetwork, err := p2pnet.New(&p2pnet.Config{
		KeyFile:            cfg.Identity.KeyFile,
		Config:             &config.Config{Network: cfg.Network},
		UserAgent:          "shurli/" + version,
		EnableRelay:        true,
		RelayAddrs:         []string{data.RelayAddr},
		ForcePrivate:       cfg.Network.ForcePrivateReachability,
		EnableNATPortMap:   true,
		EnableHolePunching: true,
	})
	if err != nil {
		fatal("P2P network error: %v", err)
	}
	defer p2pNetwork.Close()

	h := p2pNetwork.Host()
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	out("Your Peer ID: %s\n", h.ID())
	outln()

	// Connect to relay
	outln("Connecting to relay...")
	relayInfos, err := p2pnet.ParseRelayAddrs([]string{data.RelayAddr})
	if err != nil {
		fatal("Failed to parse relay address: %v", err)
	}
	for _, ai := range relayInfos {
		if err := h.Connect(ctx, ai); err != nil {
			fatal("Failed to connect to relay: %v", err)
		}
	}
	outln("Connected to relay.")

	// Add relay circuit address for the inviter
	circuitAddr := data.RelayAddr + "/p2p-circuit/p2p/" + data.PeerID.String()
	addrInfo, err := peer.AddrInfoFromString(circuitAddr)
	if err != nil {
		fatal("Failed to parse circuit address: %v", err)
	}
	h.Peerstore().AddAddrs(addrInfo.ID, addrInfo.Addrs, peerstore.PermanentAddrTTL)

	// Open invite protocol stream to inviter (allow relay circuit connections)
	outln("Connecting to inviter...")
	joinCtx := network.WithAllowLimitedConn(ctx, inviteProtocol)
	s, err := h.NewStream(joinCtx, data.PeerID, protocol.ID(inviteProtocol))
	if err != nil {
		fatal("Failed to connect to inviter: %v\n(Is the invite still active?)", err)
	}
	defer s.Close()

	joinerName := *nameFlag
	inviterName := joinPAKE(s, data.Token, joinerName)

	// Add inviter to our authorized_keys
	authKeysPath := cfg.Security.AuthorizedKeysFile
	comment := inviterName
	if comment == "" {
		comment = "invited-" + time.Now().Format("2006-01-02")
	}
	if err := auth.AddPeer(authKeysPath, data.PeerID.String(), comment); err != nil {
		if !strings.Contains(err.Error(), "already authorized") {
			log.Printf("Warning: failed to add peer to authorized_keys: %v", err)
		}
	}

	// Add inviter to names in config (if name was provided)
	if inviterName != "" {
		updateConfigNames(cfgFile, configDir, inviterName, data.PeerID.String())
	}

	outln()
	outln("=== Joined successfully! ===")
	outln()
	if inviterName != "" {
		out("Peer \"%s\" authorized and added to names.\n", inviterName)
	} else {
		out("Peer %s authorized.\n", data.PeerID.String()[:16]+"...")
	}
	out("Config: %s\n", cfgFile)
	out("Authorized keys: %s\n", authKeysPath)
	if !*nonInteractive && inviterName != "" {
		outln()
		outln("Try:")
		out("  shurli ping %s\n", inviterName)
		out("  shurli proxy %s ssh 2222\n", inviterName)
	}
}

// joinPAKE performs the PAKE-secured handshake.
// Returns the inviter's name.
func joinPAKE(s network.Stream, token [8]byte, joinerName string) string {
	// Create PAKE session
	session, err := invite.NewPAKESession()
	if err != nil {
		fatal("PAKE session error: %v", err)
	}

	// Send: [0x01] [32-byte X25519 public key]
	if _, err := s.Write([]byte{invite.VersionV1}); err != nil {
		fatal("Failed to send version byte: %v", err)
	}
	if err := session.WritePublicKey(s); err != nil {
		fatal("Failed to send public key: %v", err)
	}

	// Read inviter's public key (32 bytes)
	inviterPub, err := invite.ReadPublicKey(s)
	if err != nil {
		fatal("Failed to read inviter public key: %v", err)
	}

	// Complete DH exchange with token binding
	if err := session.Complete(inviterPub, token); err != nil {
		fatal("PAKE key exchange failed: %v", err)
	}

	// Send encrypted joiner name
	if err := session.WriteEncrypted(s, []byte(joinerName)); err != nil {
		fatal("Failed to send encrypted name: %v", err)
	}

	// Read encrypted response
	responseBytes, err := session.Decrypt(s)
	if err != nil {
		fatal("Failed to decrypt response (wrong invite code?): %v", err)
	}
	response := string(responseBytes)

	if strings.HasPrefix(response, "ERR") {
		fatal("Invite rejected: %s", response)
	}
	if !strings.HasPrefix(response, "OK") {
		fatal("Unexpected response: %s", response)
	}

	inviterName := strings.TrimPrefix(response, "OK")
	return strings.TrimSpace(inviterName)
}

// runPairJoin handles v2 relay pairing codes.
func runPairJoin(data *invite.InviteData, nameFlag, configFlag string, nonInteractive bool,
	out func(string, ...any) (int, error), outln func(...any) (int, error)) {

	outln("=== Shurli pair-join ===")
	outln()
	out("Relay:   %s\n", data.RelayAddr)
	if data.Network != "" {
		out("Network: %s\n", data.Network)
	}
	outln()

	// Resolve config.
	cfgFile, cfg, configDir, created := loadOrCreateConfig(configFlag, data.RelayAddr, data.Network)
	if created {
		out("Created new config: %s\n", cfgFile)
	} else {
		out("Using config: %s\n", cfgFile)
	}
	outln()

	// Ensure relay address from invite code is in config.
	// New configs include it via template, but existing configs
	// may not have it (e.g., after "relay remove").
	hasRelay := false
	for _, a := range cfg.Relay.Addresses {
		if a == data.RelayAddr {
			hasRelay = true
			break
		}
	}
	if !hasRelay {
		if err := addRelayToConfigFile(cfgFile, data.RelayAddr); err != nil {
			log.Printf("Warning: could not add relay to config: %v", err)
		} else {
			cfg.Relay.Addresses = append(cfg.Relay.Addresses, data.RelayAddr)
			out("Added relay address to config.\n")
		}
	}

	// Create P2P network (no connection gating for joining).
	p2pNetwork, err := p2pnet.New(&p2pnet.Config{
		KeyFile:            cfg.Identity.KeyFile,
		Config:             &config.Config{Network: cfg.Network},
		UserAgent:          "shurli/" + version,
		EnableRelay:        true,
		RelayAddrs:         []string{data.RelayAddr},
		ForcePrivate:       cfg.Network.ForcePrivateReachability,
		EnableNATPortMap:   true,
		EnableHolePunching: true,
	})
	if err != nil {
		fatal("P2P network error: %v", err)
	}
	defer p2pNetwork.Close()

	h := p2pNetwork.Host()
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	out("Your Peer ID: %s\n", h.ID())
	outln()

	// Connect to relay.
	outln("Connecting to relay...")
	relayInfos, err := p2pnet.ParseRelayAddrs([]string{data.RelayAddr})
	if err != nil {
		fatal("Failed to parse relay address: %v", err)
	}
	for _, ai := range relayInfos {
		if err := h.Connect(ctx, ai); err != nil {
			fatal("Failed to connect to relay: %v", err)
		}
	}
	outln("Connected to relay.")

	// Open pairing protocol stream to relay.
	outln("Sending pairing code...")
	relayPeerID := relayInfos[0].ID
	pairCtx := network.WithAllowLimitedConn(ctx, relay.PairingProtocol)
	s, err := h.NewStream(pairCtx, relayPeerID, protocol.ID(relay.PairingProtocol))
	if err != nil {
		fatal("Failed to open pairing stream: %v", err)
	}
	defer s.Close()

	// Send token + name.
	reqBytes := relay.EncodePairingRequest(data.TokenV2, nameFlag)
	if _, err := s.Write(reqBytes); err != nil {
		fatal("Failed to send pairing request: %v", err)
	}
	// Signal we're done writing so the relay can read.
	s.CloseWrite()

	// Read response.
	status, groupID, _, peers, err := relay.ReadPairingResponse(s)
	if err != nil {
		fatal("Pairing failed: %v", err)
	}
	if status != relay.StatusOK {
		fatal("Pairing failed (status 0x%02x)", status)
	}

	outln()
	outln("=== Paired successfully! ===")
	outln()

	// Add discovered peers to authorized_keys and config names.
	authKeysPath := cfg.Security.AuthorizedKeysFile

	// Authorize relay and annotate with group ID so hasGroupMembership() works
	// for peer-notify validation (even if this peer joined first with 0 peers).
	if groupID != "" {
		if err := auth.AddPeer(authKeysPath, relayPeerID.String(), "relay"); err != nil {
			if !strings.Contains(err.Error(), "already authorized") {
				log.Printf("Warning: failed to authorize relay: %v", err)
			}
		}
		auth.SetPeerAttr(authKeysPath, relayPeerID.String(), "group", groupID)

		// Compute and store own HMAC commitment proof for this group.
		// proof = HMAC-SHA256(token, groupID) - matches what the relay stored.
		mac := hmac.New(sha256.New, data.TokenV2)
		mac.Write([]byte(groupID))
		ownProof := mac.Sum(nil)
		auth.SetPeerAttr(authKeysPath, relayPeerID.String(), "hmac_proof", hex.EncodeToString(ownProof))
	}

	// Load existing names for conflict resolution.
	existingNames := make(map[string]bool)
	if cfg.Names != nil {
		for n := range cfg.Names {
			existingNames[n] = true
		}
	}

	for _, p := range peers {
		peerName := sanitizeYAMLName(p.Name)
		if peerName == "" {
			peerName = "peer-" + p.PeerID.String()[:8]
		}

		// Resolve name conflicts.
		finalName := uniqueName(peerName, existingNames)
		if finalName != peerName {
			out("Name \"%s\" already in use. Registered as \"%s\".\n", peerName, finalName)
			out("  Rename with: shurli config rename %s <newname>\n", finalName)
		}
		existingNames[finalName] = true

		// Authorize peer.
		if err := auth.AddPeer(authKeysPath, p.PeerID.String(), finalName); err != nil {
			if !strings.Contains(err.Error(), "already authorized") {
				log.Printf("Warning: failed to authorize peer: %v", err)
			}
		}
		if groupID != "" {
			auth.SetPeerAttr(authKeysPath, p.PeerID.String(), "group", groupID)
		}

		// Add to config names.
		updateConfigNames(cfgFile, configDir, finalName, p.PeerID.String())

		// Show verification fingerprint.
		emoji, numeric := p2pnet.ComputeFingerprint(h.ID(), p.PeerID)
		out("Peer \"%s\" authorized. [UNVERIFIED]\n", finalName)
		out("  Verification code: %s  (%s)\n", emoji, numeric)
		out("  Verify with: shurli verify %s\n", finalName)
		outln()
	}

	if len(peers) == 0 {
		outln("Authorized on relay. No other peers in this group yet.")
		outln()
	}

	out("Config: %s\n", cfgFile)
	out("Authorized keys: %s\n", authKeysPath)
	outln()

	// Auto-start daemon.
	outln("Starting daemon...")
	daemonCmd := exec.Command(os.Args[0], "daemon")
	daemonCmd.Stdout = os.Stdout
	daemonCmd.Stderr = os.Stderr
	if err := daemonCmd.Start(); err != nil {
		out("Could not auto-start daemon: %v\n", err)
		out("Start manually with: shurli daemon\n")
	} else {
		outln("Daemon started.")
		if !nonInteractive && len(peers) > 0 {
			outln()
			outln("Try:")
			out("  shurli ping %s\n", sanitizeYAMLName(peers[0].Name))
		}
	}
}

// uniqueName appends a numeric suffix if name already exists in the set.
func uniqueName(name string, existing map[string]bool) string {
	if !existing[name] {
		return name
	}
	for i := 2; i <= 100; i++ {
		candidate := fmt.Sprintf("%s-%d", name, i)
		if !existing[candidate] {
			return candidate
		}
	}
	return fmt.Sprintf("%s-%d", name, time.Now().Unix())
}

// loadOrCreateConfig tries to load an existing config, or creates a minimal one
// using the relay address and network namespace from the invite code. Returns
// the config file path, loaded config, config directory, and whether a new
// config was created.
func loadOrCreateConfig(explicitConfig, relayAddr, networkNS string) (string, *config.NodeConfig, string, bool) {
	// Try loading existing config
	cfgFile, err := config.FindConfigFile(explicitConfig)
	if err == nil {
		cfg, err := config.LoadNodeConfig(cfgFile)
		if err != nil {
			fatal("Config error: %v", err)
		}
		configDir := filepath.Dir(cfgFile)
		config.ResolveConfigPaths(cfg, configDir)
		return cfgFile, cfg, configDir, false
	}

	// No config found  - create one
	fmt.Println("No existing config found. Creating new configuration...")
	fmt.Println()

	configDir, err := config.DefaultConfigDir()
	if err != nil {
		fatal("Failed to determine config directory: %v", err)
	}

	if err := os.MkdirAll(configDir, 0700); err != nil {
		fatal("Failed to create config directory: %v", err)
	}

	// Generate identity
	keyFile := filepath.Join(configDir, "identity.key")
	peerID, err := p2pnet.PeerIDFromKeyFile(keyFile)
	if err != nil {
		fatal("Failed to generate identity: %v", err)
	}
	fmt.Printf("Generated identity: %s\n", peerID)

	// Create authorized_keys
	authKeysFile := filepath.Join(configDir, "authorized_keys")
	if _, err := os.Stat(authKeysFile); os.IsNotExist(err) {
		content := "# authorized_keys - Peer ID allowlist (one per line)\n"
		if err := os.WriteFile(authKeysFile, []byte(content), 0600); err != nil {
			fatal("Failed to create authorized_keys: %v", err)
		}
	}

	// Write config
	cfgFile = filepath.Join(configDir, "config.yaml")
	configContent := nodeConfigTemplate(relayAddr, "shurli join", networkNS)

	if err := os.WriteFile(cfgFile, []byte(configContent), 0600); err != nil {
		fatal("Failed to write config: %v", err)
	}

	// Load the config we just wrote
	cfg, err := config.LoadNodeConfig(cfgFile)
	if err != nil {
		fatal("Failed to load newly created config: %v", err)
	}
	config.ResolveConfigPaths(cfg, configDir)

	return cfgFile, cfg, configDir, true
}

// sanitizeYAMLName strips characters unsafe for use as a bare YAML key.
// Only allows alphanumeric, hyphen, underscore, and dot.
// Names are capped at 64 characters to prevent abuse from remote peers.
func sanitizeYAMLName(s string) string {
	const maxNameLen = 64
	var b strings.Builder
	b.Grow(len(s))
	for _, r := range s {
		if (r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9') || r == '-' || r == '_' || r == '.' {
			b.WriteRune(r)
			if b.Len() >= maxNameLen {
				break
			}
		}
	}
	return b.String()
}

// addRelayToConfigFile adds a relay address to the config file's relay.addresses section.
// Handles both "addresses:" (empty list) and "addresses: []" formats.
func addRelayToConfigFile(cfgFile, relayAddr string) error {
	data, err := os.ReadFile(cfgFile)
	if err != nil {
		return err
	}

	lines := strings.Split(string(data), "\n")
	var result []string
	added := false
	entry := fmt.Sprintf("    - \"%s\"", relayAddr)

	for i := 0; i < len(lines); i++ {
		trimmed := strings.TrimSpace(lines[i])

		// Handle "addresses: []" inline empty array.
		if !added && trimmed == "addresses: []" {
			idx := strings.Index(lines[i], "addresses:")
			result = append(result, lines[i][:idx]+"addresses:")
			result = append(result, entry)
			added = true
			for k := i + 1; k < len(lines); k++ {
				result = append(result, lines[k])
			}
			break
		}

		result = append(result, lines[i])

		// Handle "addresses:" multi-line format (empty or with entries).
		if !added && trimmed == "addresses:" {
			// Skip past any existing entries.
			for i+1 < len(lines) {
				next := strings.TrimSpace(lines[i+1])
				if strings.HasPrefix(next, "- ") {
					i++
					result = append(result, lines[i])
				} else {
					break
				}
			}
			result = append(result, entry)
			added = true
		}
	}

	if !added {
		return fmt.Errorf("could not find relay.addresses section")
	}

	return os.WriteFile(cfgFile, []byte(strings.Join(result, "\n")), 0600)
}

// updateConfigNames appends a name mapping to the config file.
// This does a simple text append to preserve formatting and comments.
func updateConfigNames(cfgFile, configDir, name, peerIDStr string) {
	// Sanitize name to prevent YAML injection  - the name comes from a remote peer
	name = sanitizeYAMLName(name)
	if name == "" {
		log.Printf("Warning: peer name was empty after sanitization, skipping names update")
		return
	}

	data, err := os.ReadFile(cfgFile)
	if err != nil {
		log.Printf("Warning: could not read config to update names: %v", err)
		return
	}

	content := string(data)

	// Skip if this exact name+peerID mapping already exists in the config.
	// This prevents duplicate entries when peer-notify re-delivers introductions.
	expectedEntry := fmt.Sprintf("%s: \"%s\"", name, peerIDStr)
	if strings.Contains(content, expectedEntry) {
		return
	}

	// Replace "names: {}" with a proper names block
	if strings.Contains(content, "names: {}") {
		replacement := fmt.Sprintf("names:\n  %s: \"%s\"", name, peerIDStr)
		content = strings.Replace(content, "names: {}", replacement, 1)
	} else if strings.Contains(content, "names:") {
		// Append under existing names section - find the line and add after it
		lines := strings.Split(content, "\n")
		var result []string
		added := false
		for _, line := range lines {
			result = append(result, line)
			if !added && strings.HasPrefix(strings.TrimSpace(line), "names:") && !strings.Contains(line, "{}") {
				result = append(result, fmt.Sprintf("  %s: \"%s\"", name, peerIDStr))
				added = true
			}
		}
		if !added {
			// Fallback: append at end
			result = append(result, fmt.Sprintf("\nnames:\n  %s: \"%s\"", name, peerIDStr))
		}
		content = strings.Join(result, "\n")
	} else {
		// No names section at all
		content += fmt.Sprintf("\nnames:\n  %s: \"%s\"\n", name, peerIDStr)
	}

	if err := os.WriteFile(cfgFile, []byte(content), 0600); err != nil {
		log.Printf("Warning: could not update config names: %v", err)
	}
}
